import sys
import subprocess
from datetime import datetime
from encrypt import encrypt_file
import os
import re

def main():
    if len(sys.argv) < 2:
        print("Usage: sqlmap.py <target>")
        sys.exit(1)

    target = sys.argv[1]
    date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    
    # S'assurer que le dossier rapports existe
    rapports_dir = "rapports"
    if not os.path.exists(rapports_dir):
        os.makedirs(rapports_dir)
        print(f"üìÅ Dossier {rapports_dir} cr√©√©")
    
    # Format de nom correct pour l'interface web
    html_path = os.path.join(rapports_dir, f"sqlmap_{date}.html")
    
    print(f"üîç Scan SQLMap en cours sur {target}...")
    print(f"üìÑ Fichier de sortie: {html_path}")

    # Pr√©parer les URLs √† tester (correction de l'erreur UnboundLocalError)
    if target.startswith(('http://', 'https://')):
        test_urls = [target]
    else:
        test_urls = [f"http://{target}", f"https://{target}"]
    
    # Ajouter quelques chemins de test courants avec param√®tres
    additional_paths = [
        "/index.php?id=1",
        "/login.php?user=test",
        "/search.php?q=test",
        "/product.php?id=1"
    ]
    
    # Construire la liste finale des URLs √† tester (limit√© √† 6 URLs max)
    final_test_urls = []
    for base_url in test_urls:
        final_test_urls.append(base_url)  # URL de base
        for path in additional_paths[:2]:  # Ajouter 2 chemins par protocole
            test_url = base_url + path
            final_test_urls.append(test_url)
            if len(final_test_urls) >= 6:  # Maximum 6 URLs au total
                break
        if len(final_test_urls) >= 6:
            break
    
    print(f"üéØ URLs √† tester: {len(final_test_urls)} URLs")
    for url in final_test_urls:
        print(f"   - {url}")
    
    sqlmap_results = {}
    sqlmap_available = True
    
    # V√©rifier si SQLMap est disponible
    try:
        version_check = subprocess.run(["sqlmap", "--version"], capture_output=True, timeout=10, text=True)
        if version_check.returncode == 0:
            print("‚úÖ SQLMap d√©tect√© et fonctionnel")
        else:
            print("‚ö†Ô∏è SQLMap d√©tect√© mais probl√®me de version")
    except (FileNotFoundError, subprocess.TimeoutExpired):
        print("‚ùå SQLMap non trouv√©")
        sqlmap_available = False
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de la v√©rification SQLMap: {e}")
        sqlmap_available = False
    
    for i, test_url in enumerate(final_test_urls, 1):
        print(f"üîç [{i}/{len(final_test_urls)}] Test SQLMap sur {test_url}...")
        
        if not sqlmap_available:
            sqlmap_results[test_url] = {
                'status': '‚ùå SQLMap non install√©',
                'risk_level': 'UNKNOWN',
                'vulnerabilities': [],
                'output': 'SQLMap non disponible sur ce syst√®me',
                'errors': 'Outil SQLMap non trouv√© ou non fonctionnel',
                'returncode': -2
            }
            continue
        
        try:
            # Commande SQLMap native optimis√©e
            sqlmap_cmd = [
                "sqlmap",
                "-u", test_url,
                "--batch",                     # Mode automatique, pas d'interaction
                "--random-agent",              # User-agent al√©atoire
                "--timeout", "10",             # Timeout de 10 secondes par requ√™te
                "--retries", "1",              # 1 tentative maximum
                "--level", "1",                # Niveau de test basique
                "--risk", "1",                 # Risque minimal
                "--threads", "2",              # 2 threads pour √©viter la surcharge
                "--technique", "BEUST",        # Toutes les techniques de base
                "--flush-session",             # Nettoyer les sessions pr√©c√©dentes
                "--no-logging",                # Pas de fichiers de log
                "--answers", "quit=N,follow=N,continue=N,other=N",  # R√©ponses automatiques
                "--parse-errors"               # Parser les erreurs SQL
            ]
            
            print(f"üöÄ Ex√©cution SQLMap...")
            
            sqlmap_result = subprocess.run(
                sqlmap_cmd, 
                capture_output=True, 
                text=True, 
                timeout=60  # 60 secondes max par URL
            )
            
            output = sqlmap_result.stdout if sqlmap_result.stdout else ""
            errors = sqlmap_result.stderr if sqlmap_result.stderr else ""
            
            # Analyser les r√©sultats pour d√©tecter les vuln√©rabilit√©s
            vulnerabilities_found = []
            injection_details = []
            
            if output:
                # Rechercher les indicateurs de vuln√©rabilit√©s
                lines = output.split('\n')
                for line in lines:
                    line_lower = line.lower().strip()
                    
                    # D√©tecter les vuln√©rabilit√©s confirm√©es
                    if any(keyword in line_lower for keyword in [
                        'is vulnerable', 'parameter', 'injectable', 
                        'blind sql injection', 'union query', 'error-based'
                    ]):
                        if line.strip() and len(line.strip()) > 10:
                            vulnerabilities_found.append(line.strip())
                    
                    # Extraire les d√©tails d'injection
                    if any(keyword in line_lower for keyword in [
                        'type:', 'title:', 'payload:', 'vector:'
                    ]):
                        if line.strip() and len(line.strip()) > 5:
                            injection_details.append(line.strip())
            
            # Limiter le nombre de r√©sultats pour √©viter un rapport trop long
            vulnerabilities_found = list(set(vulnerabilities_found))[:8]  # Max 8, sans doublons
            injection_details = list(set(injection_details))[:10]  # Max 10, sans doublons
            
            # D√©terminer le statut et le niveau de risque
            if vulnerabilities_found and any("vulnerable" in vuln.lower() for vuln in vulnerabilities_found):
                status = f"üö® VULN√âRABLE ({len(vulnerabilities_found)} d√©tections)"
                risk_level = "HIGH"
            elif injection_details or "might be injectable" in output.lower():
                status = f"‚ö†Ô∏è Potentiellement vuln√©rable"
                risk_level = "MEDIUM"
            elif sqlmap_result.returncode == 0:
                status = f"‚úÖ Aucune vuln√©rabilit√© d√©tect√©e"
                risk_level = "LOW"
            else:
                status = f"‚ùå Erreur lors du scan (code {sqlmap_result.returncode})"
                risk_level = "UNKNOWN"
            
            # Combiner vuln√©rabilit√©s et d√©tails
            all_findings = vulnerabilities_found + injection_details
            
            sqlmap_results[test_url] = {
                'status': status,
                'risk_level': risk_level,
                'vulnerabilities': all_findings,
                'output': output[:2000] if output else "",  # Limiter la sortie √† 2000 caract√®res
                'errors': errors[:800] if errors else "",   # Limiter les erreurs √† 800 caract√®res
                'returncode': sqlmap_result.returncode
            }
            
            print(f"   {status}")
            
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout pour {test_url}")
            sqlmap_results[test_url] = {
                'status': '‚è∞ Timeout (>60s)',
                'risk_level': 'UNKNOWN',
                'vulnerabilities': [],
                'output': 'Scan interrompu par timeout - URL trop lente √† r√©pondre',
                'errors': 'Timeout d√©pass√©',
                'returncode': -1
            }
        except Exception as e:
            error_msg = str(e)[:100]
            print(f"   ‚ùå Erreur: {error_msg}")
            sqlmap_results[test_url] = {
                'status': f'‚ùå Erreur: {error_msg}',
                'risk_level': 'UNKNOWN',
                'vulnerabilities': [],
                'output': f'Exception lors du scan: {error_msg}',
                'errors': str(e),
                'returncode': -3
            }

    # Analyser les r√©sultats globaux
    total_vulns = sum(len(r['vulnerabilities']) for r in sqlmap_results.values())
    high_risk_count = len([r for r in sqlmap_results.values() if r['risk_level'] == 'HIGH'])
    medium_risk_count = len([r for r in sqlmap_results.values() if r['risk_level'] == 'MEDIUM'])
    low_risk_count = len([r for r in sqlmap_results.values() if r['risk_level'] == 'LOW'])
    unknown_count = len([r for r in sqlmap_results.values() if r['risk_level'] == 'UNKNOWN'])
    
    print(f"\nüìä R√©sum√© du scan:")
    print(f"   üö® Vuln√©rabilit√©s critiques: {high_risk_count}")
    print(f"   ‚ö†Ô∏è Vuln√©rabilit√©s potentielles: {medium_risk_count}")
    print(f"   ‚úÖ URLs s√ªres: {low_risk_count}")
    print(f"   ‚ùì Erreurs/Inconnu: {unknown_count}")

    # G√©n√©rer le rapport HTML
    try:
        print("üìù G√©n√©ration du rapport HTML...")
        
        with open(html_path, "w", encoding='utf-8') as f:
            f.write(f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Rapport SQLMap - {target}</title>
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; line-height: 1.6; }}
        .container {{ max-width: 1200px; margin: 0 auto; background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; border-bottom: 3px solid #e74c3c; padding-bottom: 10px; margin-bottom: 30px; }}
        h2 {{ color: #34495e; margin-top: 30px; margin-bottom: 20px; }}
        h3 {{ color: #2c3e50; margin-top: 25px; }}
        .info {{ background-color: #ebf7fd; padding: 15px; border-left: 4px solid #3498db; margin: 20px 0; border-radius: 0 5px 5px 0; }}
        .success {{ background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 20px 0; border-radius: 0 5px 5px 0; }}
        .warning {{ background-color: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; margin: 20px 0; border-radius: 0 5px 5px 0; }}
        .error {{ background-color: #f8d7da; color: #721c24; padding: 15px; border-left: 4px solid #dc3545; margin: 20px 0; border-radius: 0 5px 5px 0; }}
        .critical {{ background-color: #f8d7da; color: #721c24; padding: 20px; border-left: 4px solid #dc3545; margin: 20px 0; border-radius: 0 5px 5px 0; font-weight: bold; font-size: 1.1em; }}
        .url-test {{ background-color: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 8px; border-left: 4px solid #6c757d; }}
        .vulnerability {{ background-color: #f8d7da; padding: 10px; margin: 8px 0; border-left: 3px solid #dc3545; border-radius: 0 3px 3px 0; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9em; }}
        .safe {{ background-color: #d4edda; padding: 10px; margin: 8px 0; border-left: 3px solid #28a745; border-radius: 0 3px 3px 0; }}
        .potential {{ background-color: #fff3cd; padding: 10px; margin: 8px 0; border-left: 3px solid #ffc107; border-radius: 0 3px 3px 0; }}
        pre {{ background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px; max-height: 400px; overflow-y: auto; font-family: 'Consolas', 'Monaco', monospace; }}
        .stats {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin: 25px 0; }}
        .stat {{ background-color: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff; }}
        .stat h3 {{ margin: 0; font-size: 2em; }}
        .stat p {{ margin: 10px 0 0 0; color: #666; }}
        .stat.danger {{ border-left-color: #dc3545; background-color: #f8d7da; }}
        .stat.warning {{ border-left-color: #ffc107; background-color: #fff3cd; }}
        .stat.success {{ border-left-color: #28a745; background-color: #d4edda; }}
        .risk-high {{ color: #dc3545; font-weight: bold; }}
        .risk-medium {{ color: #ffc107; font-weight: bold; }}
        .risk-low {{ color: #28a745; font-weight: bold; }}
        .risk-unknown {{ color: #6c757d; }}
        .summary {{ background-color: #f8f9fa; padding: 25px; border-radius: 8px; margin: 25px 0; }}
        .url-header {{ background-color: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-weight: bold; word-break: break-all; }}
        details {{ margin: 15px 0; }}
        summary {{ cursor: pointer; padding: 8px; background-color: #e9ecef; border-radius: 4px; font-weight: bold; }}
        summary:hover {{ background-color: #dee2e6; }}
        .tech-info {{ background-color: #f1f3f4; padding: 15px; border-radius: 5px; margin: 15px 0; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ°Ô∏è Rapport SQLMap - Test d'Injection SQL</h1>
        <div class="info">
            <strong>üéØ Cible analys√©e:</strong> {target}<br>
            <strong>üìÖ Date du scan:</strong> {datetime.now().strftime('%Y-%m-%d √† %H:%M:%S')}<br>
            <strong>üîß Outil utilis√©:</strong> SQLMap (installation native dans conteneur)<br>
            <strong>üîç URLs test√©es:</strong> {len(final_test_urls)}<br>
            <strong>‚öôÔ∏è Configuration:</strong> Scan automatis√© niveau 1, risque 1, techniques BEUST<br>
            <strong>‚è±Ô∏è Dur√©e par URL:</strong> Maximum 60 secondes
        </div>
        
        <div class="stats">
            <div class="stat {'danger' if high_risk_count > 0 else 'success'}">
                <h3>{high_risk_count}</h3>
                <p>Vuln√©rabilit√©s<br>confirm√©es</p>
            </div>
            <div class="stat {'warning' if medium_risk_count > 0 else 'success'}">
                <h3>{medium_risk_count}</h3>
                <p>Vuln√©rabilit√©s<br>potentielles</p>
            </div>
            <div class="stat success">
                <h3>{low_risk_count}</h3>
                <p>URLs<br>s√©curis√©es</p>
            </div>
            <div class="stat">
                <h3>{total_vulns}</h3>
                <p>D√©tections<br>totales</p>
            </div>
        </div>""")

            # R√©sum√© de s√©curit√© global
            if high_risk_count > 0:
                f.write(f"""
        <div class="critical">
            üö® <strong>ALERTE S√âCURIT√â CRITIQUE</strong><br>
            {high_risk_count} vuln√©rabilit√©(s) d'injection SQL confirm√©e(s) d√©tect√©e(s) !<br>
            <strong>‚ö° Action imm√©diate requise - Risque de compromission des donn√©es</strong><br>
            üí° Consultez les recommandations ci-dessous pour corriger ces failles
        </div>""")
            elif medium_risk_count > 0:
                f.write(f"""
        <div class="warning">
            ‚ö†Ô∏è <strong>Vuln√©rabilit√©s potentielles d√©tect√©es</strong><br>
            {medium_risk_count} URL(s) pr√©sentent des signes d'injection SQL possible.<br>
            Investigation manuelle recommand√©e pour confirmer les vuln√©rabilit√©s.
        </div>""")
            else:
                f.write('<div class="success"><strong>‚úÖ Aucune vuln√©rabilit√© SQL √©vidente</strong> d√©tect√©e sur les URLs test√©es avec cette configuration de scan automatis√©.</div>')

            f.write('<h2>üìä R√©sultats d√©taill√©s par URL</h2>')
            
            # Afficher les r√©sultats pour chaque URL
            for url, result in sqlmap_results.items():
                risk_class = {
                    'HIGH': 'risk-high',
                    'MEDIUM': 'risk-medium', 
                    'LOW': 'risk-low',
                    'UNKNOWN': 'risk-unknown'
                }.get(result['risk_level'], 'risk-unknown')
                
                f.write(f"""
        <div class="url-test">
            <div class="url-header">üåê {url}</div>
            <p><strong>Statut du scan:</strong> <span class="{risk_class}">{result['status']}</span></p>
            <p><strong>Niveau de risque:</strong> <span class="{risk_class}">{result['risk_level']}</span></p>""")
                
                if result['vulnerabilities']:
                    f.write('<h4>üö® Vuln√©rabilit√©s et d√©tections:</h4>')
                    for vuln in result['vulnerabilities']:
                        if vuln.strip():  # √âviter les lignes vides
                            vuln_class = "vulnerability"
                            if "might" in vuln.lower() or "potential" in vuln.lower():
                                vuln_class = "potential"
                            f.write(f'<div class="{vuln_class}">üî¥ {vuln}</div>')
                elif result['risk_level'] == 'LOW':
                    f.write('<div class="safe">‚úÖ Aucune vuln√©rabilit√© d\'injection SQL d√©tect√©e sur cette URL</div>')
                elif result['risk_level'] == 'UNKNOWN':
                    f.write('<div class="error">‚ùì Scan incomplet ou erreur lors de l\'analyse</div>')
                
                # Afficher la sortie SQLMap si disponible
                if result['output'] and len(result['output']) > 50:
                    f.write(f'<details><summary>üìÑ Sortie compl√®te de SQLMap</summary><pre>{result["output"]}</pre></details>')
                
                # Afficher les erreurs si disponibles
                if result['errors']:
                    f.write(f'<details><summary>‚ö†Ô∏è Erreurs et avertissements</summary><pre>{result["errors"]}</pre></details>')
                
                f.write('</div>')

            f.write("""
        <h2>üõ°Ô∏è Recommandations de S√©curit√©</h2>
        <div class="summary">
            <h3>üí° Actions prioritaires contre l'injection SQL</h3>
            <ul>
                <li><strong>üîí Requ√™tes pr√©par√©es:</strong> Remplacez imm√©diatement toutes les requ√™tes SQL dynamiques par des prepared statements</li>
                <li><strong>‚úÖ Validation stricte:</strong> Validez, filtrez et √©chappez toutes les entr√©es utilisateur avant utilisation</li>
                <li><strong>üîê Principe du moindre privil√®ge:</strong> Limitez les droits d'acc√®s de la base de donn√©es au strict minimum</li>
                <li><strong>üõ°Ô∏è WAF (Web Application Firewall):</strong> D√©ployez une protection applicative pour filtrer les attaques</li>
                <li><strong>üìä Monitoring continu:</strong> Surveillez et loggez toutes les tentatives d'injection SQL</li>
                <li><strong>üîÑ Tests r√©guliers:</strong> Effectuez des audits de s√©curit√© p√©riodiques</li>
                <li><strong>üìö Formation √©quipe:</strong> Sensibilisez les d√©veloppeurs aux bonnes pratiques de s√©curit√©</li>
            </ul>
        </div>
        
        <div class="info">
            <h3>üîß Exemples de code s√©curis√©</h3>
            <p><strong>PHP avec PDO (Recommand√©):</strong></p>
            <pre>// ‚ùå Code vuln√©rable √† l'injection SQL
$sql = "SELECT * FROM users WHERE id = " . $_GET['id'];
$result = $db->query($sql);

// ‚úÖ Code s√©curis√© avec requ√™te pr√©par√©e
$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");
$stmt->execute([$_GET['id']]);
$result = $stmt->fetchAll();

// ‚úÖ Alternative avec param√®tres nomm√©s
$stmt = $pdo->prepare("SELECT * FROM users WHERE id = :id AND status = :status");
$stmt->execute([':id' => $_GET['id'], ':status' => 'active']);</pre>
            
            <p><strong>Python avec SQLAlchemy:</strong></p>
            <pre>// ‚ùå Code vuln√©rable
query = f"SELECT * FROM users WHERE id = {user_id}"
result = db.execute(query)

// ‚úÖ Code s√©curis√©
result = db.execute("SELECT * FROM users WHERE id = :id", {"id": user_id})

// ‚úÖ Avec ORM SQLAlchemy
user = session.query(User).filter(User.id == user_id).first()</pre>

            <p><strong>Node.js avec Sequelize:</strong></p>
            <pre>// ‚ùå Code vuln√©rable
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query);

// ‚úÖ Code s√©curis√©
const user = await User.findOne({ where: { id: userId } });</pre>
        </div>
        
        <div class="tech-info">
            <h3>üîç Techniques d'injection test√©es par SQLMap</h3>
            <ul>
                <li><strong>Boolean-based blind:</strong> Injection aveugle bas√©e sur des conditions vraies/fausses</li>
                <li><strong>Error-based:</strong> Injection exploitant les messages d'erreur de la base de donn√©es</li>
                <li><strong>Union query:</strong> Injection utilisant l'op√©rateur UNION SELECT pour extraire des donn√©es</li>
                <li><strong>Stacked queries:</strong> Injection permettant l'ex√©cution de requ√™tes multiples</li>
                <li><strong>Time-based blind:</strong> Injection aveugle bas√©e sur les d√©lais de r√©ponse</li>
            </ul>
        </div>
        
        <div class="warning">
            <h3>‚ö†Ô∏è Limitations de ce scan automatis√©</h3>
            <ul>
                <li><strong>Configuration conservatrice:</strong> Scan rapide avec param√®tres de s√©curit√© (niveau 1, risque 1)</li>
                <li><strong>Nombre d'URLs limit√©:</strong> Test sur {len(final_test_urls)} URLs pour √©viter les timeouts</li>
                <li><strong>Timeout r√©duit:</strong> 60 secondes maximum par URL pour optimiser les performances</li>
                <li><strong>Audit complet recommand√©:</strong> Ce scan ne remplace pas un test de p√©n√©tration approfondi</li>
                <li><strong>Faux n√©gatifs possibles:</strong> Certaines vuln√©rabilit√©s complexes peuvent ne pas √™tre d√©tect√©es</li>
                <li><strong>Tests manuels conseill√©s:</strong> V√©rification manuelle recommand√©e pour les URLs √† fort enjeu</li>
            </ul>
        </div>
        
        <div class="error">
            <h3>üö® Plan d'action d'urgence si vuln√©rabilit√©s d√©tect√©es</h3>
            <ol>
                <li><strong>üîí Isolement imm√©diat:</strong> Restreindre l'acc√®s aux URLs vuln√©rables</li>
                <li><strong>üõ†Ô∏è Correction du code:</strong> Impl√©menter des requ√™tes pr√©par√©es sur les param√®tres vuln√©rables</li>
                <li><strong>‚úÖ Validation renforc√©e:</strong> Ajouter une validation stricte de toutes les entr√©es utilisateur</li>
                <li><strong>üß™ Tests de r√©gression:</strong> V√©rifier que les corrections √©liminent les vuln√©rabilit√©s</li>
                <li><strong>üìã Audit complet:</strong> Effectuer un audit de s√©curit√© approfondi de l'application</li>
                <li><strong>üìä Monitoring:</strong> Mettre en place une surveillance continue des tentatives d'attaque</li>
                <li><strong>üìö Documentation:</strong> Documenter les corrections et former l'√©quipe de d√©veloppement</li>
            </ol>
        </div>
        
        <div class="info">
            <h3>üìû Ressources et support</h3>
            <p>
                <strong>üåê Documentation SQLMap:</strong> <a href="https://sqlmap.org/" target="_blank">https://sqlmap.org/</a><br>
                <strong>üìö OWASP SQL Injection:</strong> <a href="https://owasp.org/www-community/attacks/SQL_Injection" target="_blank">Guide OWASP</a><br>
                <strong>üîí S√©curisation des applications web:</strong> Consultez un expert en cybers√©curit√© pour un audit complet
            </p>
        </div>
        
        <div class="tech-info">
            <p><strong>üìÑ Rapport g√©n√©r√© automatiquement par SQLMap</strong> - Version conteneuris√©e<br>
            <em>Ce rapport est confidentiel et destin√© uniquement aux √©quipes autoris√©es</em></p>
        </div>
    </div>
</body>
</html>""")
        
        print(f"‚úÖ Rapport HTML g√©n√©r√© avec succ√®s: {html_path}")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la g√©n√©ration du rapport HTML: {e}")
        import traceback
        print(f"Traceback complet: {traceback.format_exc()}")
        return

    # Chiffrement du rapport
    try:
        if not os.path.exists(html_path):
            print(f"‚ùå Fichier {html_path} introuvable pour le chiffrement")
            return
            
        if os.path.getsize(html_path) == 0:
            print(f"‚ùå Fichier {html_path} vide, impossible de chiffrer")
            return
            
        print("üîí Chiffrement du rapport en cours...")
        encrypt_file(html_path)
        
        encrypted_path = html_path + ".aes"
        if os.path.exists(encrypted_path):
            encrypted_size = os.path.getsize(encrypted_path)
            print(f"‚úÖ Rapport chiffr√© avec succ√®s: {os.path.basename(encrypted_path)} ({encrypted_size} bytes)")
            
            # Supprimer le fichier non chiffr√© pour la s√©curit√©
            try:
                os.remove(html_path)
                print(f"üóëÔ∏è Fichier non chiffr√© supprim√© pour la s√©curit√©")
            except Exception as cleanup_error:
                print(f"‚ö†Ô∏è Impossible de supprimer le fichier non chiffr√©: {cleanup_error}")
        else:
            print("‚ùå Le fichier chiffr√© n'a pas √©t√© cr√©√© correctement")
        
    except Exception as e:
        print(f"‚ùå Erreur lors du chiffrement: {e}")
        import traceback
        print(f"Traceback chiffrement: {traceback.format_exc()}")

    print(f"\nüéØ Scan SQLMap termin√© pour {target}")
    print(f"üìä R√©sultats: {high_risk_count} critiques, {medium_risk_count} potentielles, {low_risk_count} s√ªres")
    if high_risk_count > 0:
        print(f"‚ö†Ô∏è ATTENTION: Des vuln√©rabilit√©s critiques ont √©t√© d√©tect√©es!")

if __name__ == "__main__":
    main()